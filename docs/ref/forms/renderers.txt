======================
The form rendering API
======================

.. versionadded:: 1.11

Django form widgets are rendered using the Django template backend system.

The form rendering process can be customized at several levels:

* Widgets can specify custom template names.
* Forms and widgets can specify custom renderer classes.
* Built-in templates can be overridden within a project or application.

.. _low-level-widget-render-api:

The low-level render API
------------------------

Widget templates are stored in the ``django/forms/widgets`` path. A project
can provide a custom template for ``input.html`` by defining
``django/forms/widgets/input.html``, for example.

The rendering of form templates is controlled by a customizable renderer class.
A custom renderer can be specified by updating the :setting:`FORM_RENDERER`
setting. It defaults to ``'django.forms.renderers.templates.TemplateRenderer'``.

.. module:: django.forms.renderers.templates

.. class:: TemplateRenderer

.. method:: get_template(template_name)

    Given a template name, returns a :class:`~django.template.Template` object,
    or raises :exc:`~django.template.TemplateDoesNotExist`. First attempts to
    load the template via :class:`~django.template.loader.get_template`, which
    uses the template engines configured in :setting:`TEMPLATES`. If the
    template is not found by those engines, it falls back to the built-in form
    templates shipped with Django (using Jinja2 if installed or Django
    template language otherwise).

.. method:: render(template_name, context, request=None)

    Renders the ``template_name`` and ``context``. Calls :meth:`.get_template`
    to load the given ``template_name``.

    If you implement a custom renderer, this is the only method that Django
    calls and therefore that you must implement. :meth:`get_template` is called
    by ``TemplateRenderer.render()``, but your render doesn't need to follow
    this pattern.

If you want to use a custom template engine specifically for form rendering,
you could create your own custom renderer subclass like::

    from django.forms.renderers.templates import TemplateRenderer
    from django.utils.functional import cached_property

    class MyRenderer(TemplateRenderer):
        def get_template(self, template_name):
            return self.engine.get_template(template_name)

        @cached_property
        def engine(self):
            return Jinja2({
                'APP_DIRS': False,
                'DIRS': ['/path/to/templates/'],
                'NAME': 'djangoforms',
                'OPTIONS': {},
            })

.. class:: StandaloneTemplateRenderer

Django includes a simple renderer class that uses only the built-in default
form templates and doesn't require (or use) any template engines configured via
the :setting:`TEMPLATES` setting. This may be useful for standalone usage of
``django.forms`` or just for simplicity if you don't ever need to
override or add to the default form templates. To use this renderer, set
:setting:`FORM_RENDERER` to
``'django.forms.renderers.templates.StandaloneTemplateRenderer'``. It uses
a :class:`~django.template.backends.jinja2.Jinja2` backend if installed or
:class:`~django.template.backends.django.DjangoTemplates` otherwise.

Customizing widget rendering
----------------------------

Form widgets are rendered with the Django template system. This gives you full
control of widget output.

Each widget has a ``template_name`` attribute, such as
``'django/forms/widgets/textarea.html'``. See :ref:`built-in widgets` for the
name of each widget's template.

When rendered, the template receives a context from
:meth:`.Widget.get_context`. By default, widgets receive a single value in the
context, ``widget``. This is a dictionary that contains values like:

* ``name``
* ``value``
* ``attrs``
* ``is_hidden``
* ``template_name``

Some widgets add further information to the context. For instance, all widgets
that subclass ``Input`` defines ``widget['type']`` and :class:`.MultiWidget`
defines ``widget['subwidgets']`` for looping purposes.

Overriding widget templates works the same as overriding other templates. The
:class:`TemplateRenderer` uses :func:`~django.template.loader.get_template` to
find a template.

Overriding the renderer per form
--------------------------------

You can provide a custom render by setting the :attr:`.Form.default_renderer`
attribute or by using the ``renderer`` argument of :meth:`.Widget.render`.
